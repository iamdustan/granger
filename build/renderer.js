// Generated by CoffeeScript 1.4.0
(function() {
  var DomRenderer, Renderer,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Renderer = (function() {

    Renderer.version = '0.1.0';

    function Renderer(granger) {
      this.granger = granger;
      this.options = this.granger.options;
      this._createElements();
      this._bindEvents();
    }

    Renderer.prototype._createElements = function() {
      return console.log('Error: _createElements not available. Renderer should not be instantiated directly');
    };

    Renderer.prototype._bindEvents = function() {
      return console.log('Error: _bindEvents not available. Renderer should not be instantiated directly');
    };

    Renderer.prototype.sync = function(x, y) {};

    Renderer.prototype.draw = function(x, y) {
      this.pointer.style.left = x + 'px';
      return this.pointer.style.top = y + 'px';
    };

    Renderer.prototype.pointByAngle = function(x, y) {
      var radians;
      radians = Math.atan2(this.dim.centerY - y, this.dim.centerX - x);
      x = -1 * this.dim.radius * Math.cos(radians) + this.dim.centerX;
      y = -1 * this.dim.radius * Math.sin(radians) + this.dim.centerY;
      return {
        x: x,
        y: y
      };
    };

    Renderer.prototype.pointByLimit = function(x, y) {
      var distance, distanceSquared, dx, dy, ratio;
      dx = x - this.dim.centerX;
      dy = y - this.dim.centerY;
      distanceSquared = (dx * dx)(+(dy * dy));
      if (distanceSquared <= this.dim.radius * this.dim.radius) {
        return {
          x: x,
          y: y
        };
      }
      distance = Math.sqrt(distanceSquared);
      ratio = this.dim.radius / distance;
      x = dx * ratio + this.dim.centerX;
      y = dy * ratio + this.dim.centerY;
      return {
        x: x,
        y: y
      };
    };

    Renderer.prototype.getPoint = function(x, y) {
      if (this.options.freeBounds) {
        return this.pointByLimit(x, y);
      }
      return this.pointByAngle(x, y);
    };

    return Renderer;

  })();

  DomRenderer = (function(_super) {

    __extends(DomRenderer, _super);

    function DomRenderer() {
      return DomRenderer.__super__.constructor.apply(this, arguments);
    }

    DomRenderer.prototype._createElements = function() {
      this.canvas = document.createElement('div');
      this.pointer = document.createElement('div');
      this.canvas.setAttribute('class', 'granger');
      this.pointer.setAttribute('class', 'granger-pointer');
      this.granger.element.style.display = 'none';
      this.canvas.style.cursor = 'pointer';
      this.canvas.style.mozUserSelect = 'none';
      this.canvas.style.webkitUserSelect = 'none';
      this.granger.element.parentNode.insertBefore(this.canvas, this.element);
      this.granger.element.parentNode.insertBefore(this.pointer, this.element);
      this.dim = {
        width: this.canvas.offsetWidth,
        height: this.canvas.offsetHeight,
        top: this.canvas.offsetTop,
        left: this.canvas.offsetLeft
      };
      this.dim.centerX = this.dim.left + this.dim.width / 2;
      this.dim.centerY = this.dim.top + this.dim.height / 2;
      this.dim.radius = this.dim.width / 2 - this.pointer.offsetWidth / 2;
      this.draw(this.dim.centerX, this.dim.centerY);
      return this;
    };

    DomRenderer.prototype._bindEvents = function() {
      var onDrag, onEnd, onStart,
        _this = this;
      onStart = function(e) {
        _this.isDragging = true;
        return false;
      };
      onDrag = function(e) {
        var result, x, y;
        if (!_this.isDragging) {
          return;
        }
        if (e.type === 'touchmove') {
          x = e.touches[0].pageX;
          y = e.touches[0].pageY;
        } else {
          x = e.x;
          y = e.y;
        }
        result = _this.getPoint(x, y);
        _this.sync(result.x, result.y);
        _this.draw(result.x, result.y);
        e.preventDefault();
        return false;
      };
      onEnd = function(e) {
        _this.isDragging = false;
        return false;
      };
      this.canvas.addEventListener('mousedown', onStart, false);
      this.canvas.addEventListener('mousemove', onDrag, false);
      this.canvas.addEventListener('mouseup', onEnd, false);
      this.pointer.addEventListener('mousedown', onStart, false);
      this.pointer.addEventListener('mousemove', onDrag, false);
      this.pointer.addEventListener('mouseup', onEnd, false);
      this.canvas.addEventListener('touchstart', onStart, false);
      this.canvas.addEventListener('touchmove', onDrag, false);
      return this.canvas.addEventListener('touchend', onEnd, false);
    };

    return DomRenderer;

  })(Renderer);

  window.DomRenderer = DomRenderer;

}).call(this);
